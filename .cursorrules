# SeÃ±or Arroz - Cursor Rules

## Contexto del Proyecto
Este es un sistema de gestiÃ³n de restaurante desarrollado en Vue 3 + TypeScript + Tailwind CSS. El proyecto maneja pedidos, clientes, productos, pagos y mÃºltiples roles de usuario.

## DocumentaciÃ³n Principal
- **agents.md** - DocumentaciÃ³n completa del proyecto
- **docs/README.md** - Overview y navegaciÃ³n
- **docs/architecture.md** - Arquitectura tÃ©cnica detallada
- **docs/components.md** - GuÃ­a de componentes UI
- **docs/business-rules.md** - Reglas de negocio del sistema
- **docs/api-reference.md** - Referencia completa de APIs
- **docs/development.md** - GuÃ­as de desarrollo y convenciones

## Stack TecnolÃ³gico
- **Frontend**: Vue 3.5.18 + Composition API + TypeScript 5.8.3
- **Styling**: Tailwind CSS 4.1.13
- **Estado**: Pinia 3.0.3 (stores modulares)
- **Routing**: Vue Router 4.5.1
- **HTTP**: Axios 1.12.1 con interceptores JWT
- **Icons**: Heroicons 2.2.0
- **Build**: Vite 7.1.2
- **Testing**: Vitest 3.2.4

## Sistema de Colores
- **Primario**: Emerald (Verde) - `#009966`, `emerald-600`, `emerald-700`
- **Secundario**: Gray - `gray-50`, `gray-100`, `gray-300`, `gray-500`, `gray-700`, `gray-900`
- **Ã‰xito**: Green - `green-600`, `green-700`
- **Peligro**: Red - `red-600`, `red-700`
- **Advertencia**: Yellow/Orange
- **Info**: Blue

## Roles del Sistema
- **SUPERADMIN**: Acceso total al sistema
- **ADMIN**: Administrador de sucursal
- **CASHIER**: Cajero
- **KITCHEN**: Cocina
- **DELIVERYMAN**: Domiciliario

## Reglas de Desarrollo

### Reactividad Optimista (REGLA CRÃTICA)

**IMPORTANTE**: DespuÃ©s de mutaciones (CREATE, UPDATE, DELETE), **SIEMPRE actualizar el estado local inmediatamente** sin recargar desde el servidor. Esto proporciona una UX instantÃ¡nea.

#### PatrÃ³n a seguir:

**CREATE - Agregar al array local:**
```typescript
const created = await api.create(data)
items.value.unshift(created)  // Agregar al inicio de la lista
if (totalCount.value !== undefined) totalCount.value++
// âŒ NO hacer: await fetchAll()
```

**UPDATE - Actualizar item en el array local:**
```typescript
const updated = await api.update(id, data)

// Encontrar y actualizar en la lista
const index = items.value.findIndex(item => item.id === id)
if (index !== -1) {
    items.value[index] = { ...items.value[index], ...updated }
}

// âŒ NO hacer: await fetchAll()
```

**DELETE - Remover del array local:**
```typescript
await api.delete(id)
items.value = items.value.filter(item => item.id !== id)
if (totalCount.value !== undefined) totalCount.value--
// âŒ NO hacer: await fetchAll()
```

#### Ejemplo implementado en OrdersList.vue:
```typescript
const handleChangeStatus = async (order: OrderListItem) => {
    const updatedOrder = await orderApi.updateStatus(order.id, nextStatus)
    
    // âœ… ActualizaciÃ³n optimista
    const index = orders.value.findIndex(o => o.id === order.id)
    if (index !== -1) {
        orders.value[index] = {
            ...orders.value[index],
            status: updatedOrder.status,
            statusDisplayName: getStatusDisplayName(updatedOrder.status),
            updatedAt: updatedOrder.updatedAt
        }
    }
    // âŒ NO: await fetchOrders()
}
```

#### Emits de componentes child:
Los componentes child (modales, forms) deben **emitir el objeto actualizado**:
```typescript
// En el modal/componente
const emit = defineEmits<{
    updated: [item?: EntityType]  // Incluir el objeto actualizado
}>()

const handleSave = async () => {
    const updated = await api.update(id, data)
    emit('updated', updated)  // âœ… Pasar el objeto
}

// En el padre
const handleUpdated = (updated?: EntityType) => {
    if (updated) {
        // Actualizar localmente
        const index = items.value.findIndex(i => i.id === updated.id)
        if (index !== -1) {
            items.value[index] = { ...items.value[index], ...updated }
        }
    }
}
```

#### CuÃ¡ndo SÃ recargar desde el servidor:
- âœ… Cambios que afectan mÃºltiples items a la vez
- âœ… Operaciones complejas que el backend calcula (totales, agregaciones)
- âœ… Al cambiar de pÃ¡gina en paginaciÃ³n
- âœ… Al aplicar filtros nuevos
- âœ… Errores de sincronizaciÃ³n detectados

#### Beneficios:
- âš¡ UI instantÃ¡nea sin esperas de red
- ğŸ“‰ Menos carga en el servidor
- ğŸ¯ Mejor experiencia de usuario
- ğŸ”„ Datos siempre sincronizados (el servidor devuelve el objeto actualizado)

### Naming Conventions
- **Componentes**: PascalCase (`BaseButton.vue`, `OrderSidebar.vue`)
- **Archivos**: camelCase para servicios (`authApi.ts`), PascalCase para componentes
- **Variables**: camelCase (`isLoading`, `userRole`)
- **Constantes**: UPPER_SNAKE_CASE (`API_BASE_URL`)
- **Types/Interfaces**: PascalCase (`User`, `Order`)
- **Events**: kebab-case (`@user-selected`, `@order-updated`)

### Estructura de Archivos
```
src/
â”œâ”€â”€ components/           # Componentes Vue
â”‚   â”œâ”€â”€ layout/          # Layout components (Sidebar, TopNav, etc.)
â”‚   â”œâ”€â”€ ui/              # Base UI components (BaseButton, BaseInput, etc.)
â”‚   â””â”€â”€ [feature].vue    # Feature-specific components
â”œâ”€â”€ views/               # Page components
â”œâ”€â”€ store/               # Pinia stores
â”œâ”€â”€ services/            # API services
â”‚   â””â”€â”€ MainAPI/         # APIs especÃ­ficas por dominio
â”œâ”€â”€ types/               # TypeScript definitions
â”œâ”€â”€ composables/         # Vue composables
â”œâ”€â”€ router/              # Vue Router config
â””â”€â”€ assets/              # Static assets
```

### Patrones de Componentes
- Usar Composition API con `<script setup lang="ts">`
- Props tipadas con TypeScript
- Events tipados con `defineEmits`
- Usar Tailwind CSS para estilos
- Seguir estructura: Imports â†’ Props/Emits â†’ Composables â†’ State â†’ Computed â†’ Methods â†’ Lifecycle

### Stores de Pinia
- Usar Composition API style (`defineStore` con funciÃ³n)
- Separar state (ref), getters (computed) y actions
- Manejar loading y error states
- Usar tipos TypeScript estrictos

### APIs
- Extender de `BaseApi` class
- Manejar errores con try/catch
- Usar interceptores para JWT
- Tipar responses con TypeScript

## Reglas de Negocio Importantes

### Pedidos
- **Delivery**: Cliente + direcciÃ³n obligatorios
- **Reservation**: Fecha/hora de entrega obligatoria
- **App Payments**: MÃ¡ximo 1 por pedido
- **Bank Payments**: MÃºltiples permitidos
- **CancelaciÃ³n**: Requiere motivo

### Usuarios
- Solo 1 superadmin en el sistema
- 1 admin/cocina por sucursal
- Usuarios solo ven datos de su sucursal (excepto superadmin)

### Pagos
- Apps se liquidan creando bank_payment
- Si no hay expense_bank_payment â†’ 100% efectivo
- MÃºltiples app_payments pueden liquidarse juntos

## Componentes UI Base Disponibles
- `BaseButton`: BotÃ³n con variantes (primary, secondary, danger, success, outline, ghost)
- `BaseInput`: Input con validaciÃ³n y estados
- `BaseCard`: Tarjeta contenedora
- `BaseDialog`: Modal/Dialog
- `BaseLoading`: Spinner de carga
- `BaseAlert`: Alertas y notificaciones
- `BaseToast`: Sistema de toasts
- `BaseSelect`: Select con bÃºsqueda dinÃ¡mica y opciÃ³n de creaciÃ³n
- `BaseRadioGroup`: Grupo de radio buttons con estilo segmentado (iOS-style)

## Comandos de Desarrollo
```bash
npm run dev          # Desarrollo
npm run build        # Build producciÃ³n
npm run test         # Tests
npm run test:ui      # UI de testing
```

## Variables de Entorno
```bash
VITE_API_URL=https://localhost:7049/api  # URL del backend
```

## Para Nuevos Desarrolladores
1. Leer `agents.md` para contexto general
2. Revisar `docs/README.md` para overview
3. Estudiar `docs/architecture.md` para setup tÃ©cnico
4. Consultar `docs/components.md` para patrones UI
5. Entender `docs/business-rules.md` para reglas del negocio
6. Usar `docs/api-reference.md` para integraciÃ³n backend
7. Seguir `docs/development.md` para convenciones

## Para Agentes IA
- Usar este archivo como contexto principal
- Consultar `agents.md` para informaciÃ³n completa
- Seguir patrones establecidos en `docs/components.md`
- Respetar reglas de negocio en `docs/business-rules.md`
- Mantener consistencia con el sistema de diseÃ±o
- Usar tipos TypeScript estrictos
- Preferir componentes base reutilizables
